// Firestore Security Rules for React Native (Expo) project
// Ensures proper access control for users, goals, activities, and places

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Users collection and all subcollections
    // Users can only access their own documents and subcollections
    match /users/{userId}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Specific rules for user goals subcollection
    // Provides more granular control if needed
    match /users/{userId}/goals/{goalId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Specific rules for user quests subcollection
    // Users can only access their own quests
    match /users/{userId}/quests/{questId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Create: ensure userId field matches path
      allow create: if request.auth != null && request.auth.uid == userId
        && request.resource.data.userId == userId;
      
      // Update: owner only + userId immutable
      allow update: if request.auth != null && request.auth.uid == userId
        && request.resource.data.userId == resource.data.userId
        && resource.data.userId == userId;
      
      // Delete: owner only
      allow delete: if request.auth != null && request.auth.uid == userId
        && resource.data.userId == userId;
    }
    
    // Specific rules for user activities subcollection
    // Ensures activities can only be accessed by the goal owner
    match /users/{userId}/activities/{activityId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Specific rules for user calendar events subcollection
    // Ensures calendar events can only be accessed by the user
    match /users/{userId}/calendarEvents/{eventId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Debug subcollection for connectivity testing
    // Users can ping their own debug documents
    match /users/{userId}/__debug__/{debugDoc} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Verifications collection - user-specific access
    // Users can only access their own verifications
    match /verifications/{verificationId} {
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow read, update, delete: if request.auth != null 
        && request.auth.uid == resource.data.userId
        && (request.method != 'update' || request.resource.data.userId == resource.data.userId);
    }
    
    // Goals collection (legacy/global) - user-specific access
    // Users can only access their own goals
    match /goals/{goalId} {
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow read, update, delete: if request.auth != null 
        && request.auth.uid == resource.data.userId
        && (request.method != 'update' || request.resource.data.userId == resource.data.userId);
    }
    
    // Places index collection - globally readable for location search
    // Only admins can write (requires custom claims)
    match /placesIndex/{placeId} {
      allow read: if true; // Anyone can read places for location search
      allow write: if request.auth != null && request.auth.token.admin == true;
    }
    
    // Feed posts collection - community sharing
    // Public posts are readable by all, owners can update/delete
    match /feedPosts/{postId} {
      allow read: if resource.data.visibility == 'public' && resource.data.isDeleted == false;
      allow create: if request.auth != null 
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.isDeleted == false;
      allow update, delete: if request.auth != null 
        && request.auth.uid == resource.data.userId;
    }
    
    // Feed reactions collection - likes, trust, saves
    // Users can only manage their own reactions
    match /feedReactions/{reactionId} {
      allow read: if true;
      allow create, update: if request.auth != null 
        && request.resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null 
        && resource.data.userId == request.auth.uid;
    }
    
    // Feed comments subcollection - nested under feedComments/{postId}/comments/{commentId}
    // Anyone can read non-deleted comments, only comment owner can delete
    match /feedComments/{postId}/comments/{commentId} {
      allow read: if resource.data.isDeleted == false;
      allow create: if request.auth != null 
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.postId == postId
        && request.resource.data.isDeleted == false;
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.userId;
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.userId;
    }

    // Quest verifications collection - for swipe verification
    match /questVerifications/{verificationId} {
      // Anyone can read pending verifications except their own
      allow read: if request.auth != null 
        && (resource.data.status == 'pending' || request.auth.uid == resource.data.userId);
      
      // Users can create verifications for their quests
      allow create: if request.auth != null 
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.status == 'pending';
      
      // Users can verify others' quests (but not their own)
      allow update: if request.auth != null 
        && request.auth.uid != resource.data.userId
        && resource.data.status == 'pending'
        && (request.resource.data.status == 'success' || request.resource.data.status == 'failed')
        && request.resource.data.verifiedBy == request.auth.uid;
    }
    
    // Deny all other access by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

// Example custom claims structure for admin users:
// {
//   "admin": true,
//   "moderator": false
// }
//
// These claims can be set server-side using Firebase Admin SDK:
// admin.auth().setCustomUserClaims(uid, { admin: true });
